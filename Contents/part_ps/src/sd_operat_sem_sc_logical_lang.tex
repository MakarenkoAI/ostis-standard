\begin{SCn}
\scnsectionheader{Предметная область и онтология операционной семантики логических sc-языков}
\scntext{аннотация}{Логические модели решения задач являются основой обработки знаний в интеллектуальных системах. В данной главе рассматривается интеграция различных моделей решения задач, в том числе принципы логического вывода, для решения задач на основе общей формальной модели.}
\begin{scnsubstruct}

\scnheader{Предметная область операционной семантики логических sc-языков}
\scniselement{предметная область}
\begin{scnrelfromlist}{соавтор}
    \scnitem{Ивашенко В. П.}
    \scnitem{Шункевич Д. В.}
    \scnitem{Василевская А. П.}
    \scnitem{Орлов М. К.}
\end{scnrelfromlist}

\begin{scnrelfromvector}{библиография}
    \scnitem{\scncite{Lawan2019}}
    \scnitem{\scncite{Golenkov1996_2}}
    \scnitem{\scncite{Averin2004}}
    \scnitem{\scncite{Sethy2021}}
    \scnitem{\scncite{Norton2019}}
    \scnitem{\scncite{Yuxuan2022}}
    \scnitem{\scncite{Safawi2015}}
    \scnitem{\scncite{Gungov2018}}
    \scnitem{\scncite{Geramian2017}}
    \scnitem{\scncite{Son2017}}
    \scnitem{\scncite{Uehara2017}}
    \scnitem{\scncite{Lupea2002}}
    \scnitem{\scncite{Weydert2022}}
    \scnitem{\scncite{Chen2021}}
    \scnitem{\scncite{Rybakov2020}}
    \scnitem{\scncite{Orlov2022b}}
    \scnitem{\scncite{Gavrilova2001}}
\end{scnrelfromvector}

\scnheader{логика}
\begin{scnrelfromlist}{решаемая задача}
    \scnitem{доказательство высказывания}
    \scnitem{аргументация высказывания}
    \scnitem{задача генерации гипотезы}
    \scnitem{задача опровержения гипотезы}
    \begin{scnindent}
        \scncomment{Некоторые гипотезы могут быть опровергнуты, однако извлекая причины того, почему гипотеза опровергнута, можно изменить посылку гипотезы так, чтобы создать новую гипотезу, которая впоследствии может стать теоремой.}
    \end{scnindent}
\end{scnrelfromlist}

\scnheader{современная логика}
\scnrelfrom{объект изучения}{формальный язык}
\begin{scnindent}
    \scnrelfrom{решаемая задача}{выражение логических утверждений}
\end{scnindent}
\scncomment{Логика не изучает то, как были получены знания, она позволяет представлять знания, а также из существующих знаний вывести новые (то есть из имеющихся формул логики вывести новые формулы этой же логики), установить правильность рассуждений.}

\scnheader{логический язык}
\scniselement{формальный язык}
\begin{scnrelfromlist}{цель использования}
    \scnitem{воспроизведение логических формул контекстов естественного языка}
    \scnitem{выражение логических законов}
    \scnitem{выражение способов правильных рассуждений в логических теориях, строящихся в данном языке}
\end{scnrelfromlist}

\scnheader{система логического вывода}
\begin{scnrelfromlist}{используемое средство}
    \scnitem{правило прямого заключения}
    \scnitem{правило резолюции}
\end{scnrelfromlist}
\begin{scnrelfromlist}{актуальная проблема}
    \scnitem{проблема совместимости систем логического вывода}
    \scnitem{проблема коллективного решения задач с использованием различных моделей решения задач}
\end{scnrelfromlist}

\scnheader{модель решения задач}
\begin{scnrelfromlist}{задается}
    \scnitem{язык представления методов решения задач}
    \begin{scnindent}
        \scnrelfrom{обеспечивает}{представление в памяти кибернетической системы некоторого класса методов решения задач}
    \end{scnindent}
    \scnitem{интерпретатор методов решения задач}
    \begin{scnindent}
        \scnrelfrom{определяет}{операционная семантика языка представления методов решения задач}
        \begin{scnindent}
            \scnrelto{имеет операционную семантику}{язык представления методов решения задач}
        \end{scnindent}
    \end{scnindent}
\end{scnrelfromlist}

\scnheader{логическая модель решения задач}
\scniselement{модель решения задач}
\scnrelfrom{задается}{языки логических моделей решения задач}
\begin{scnindent}
    \scnhaselement{Rule Interchange Format}
    \begin{scnindent}
        \scnidtf{RIF}
        \scnrelto{используемый язык}{Semantic Web}
        \scnrelfrom{библиографический источник}{\scncite{Lawan2019}}
    \end{scnindent}
    \scnhaselement{Semantic Web Rule Language}
    \begin{scnindent}
        \scnidtf{SWRL}
        \scnrelto{используемый язык}{Semantic Web}
        \scnrelfrom{библиографический источник}{\scncite{Lawan2019}}
        \begin{scnrelfromlist}{пример}
            \scnheader{Рисунок. Запись правил на языке SWRL}
            \scneqimage[30em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/swrl_example.png}
        \end{scnrelfromlist}
    \end{scnindent}
    \scnhaselement{SHACL Rules}
    \begin{scnindent}
        \scnrelto{используемый язык}{Semantic Web}
        \scnrelfrom{библиографический источник}{\scncite{Lawan2019}}
    \end{scnindent}
    \scnhaselement{Notation3 Rules}
    \begin{scnindent}
        \scnrelto{используемый язык}{Semantic Web}
        \scnrelfrom{библиографический источник}{\scncite{Lawan2019}}
    \end{scnindent}
    \scnrelfrom{проблема}{проблема языков логических моделей решения задач}
    \begin{scnindent}
        \scnnote{Описанные языки не предусматривают возможность представления формул в различных видах логик, поэтому при помощи них невозможно решить описанные проблемы. Языки правил специально построены для вывода следствий. Синтаксис и семантика языков онтологий и языков правил довольно сильно отличаются, поэтому возникает вопрос, как их совмещать.}
    \end{scnindent}
\end{scnindent}

\scnheader{Пролог}
\scniselement{язык программирования}
\scniselement{система логического программирования}
\scnrelfrom{база знаний}{база знаний системы Пролог}
\begin{scnindent}
    \scnrelfrom{включение}{информация в виде предикатов}
\end{scnindent}
\scnrelfrom{тип программирования}{логическое программирование}
\begin{scnindent}
    \begin{scnrelfromset}{используемые правила вывода}
        \scnitem{правило резолюции}
    \end{scnrelfromset}
\end{scnindent}
\scnrelfrom{задача программы}{доказательство истинности формулы}
\begin{scnindent}
    \scnrelfrom{доказываемая формула}{
        \begin{scnstruct}
            \scnheader{вывод}
            \scnrelfrom{посылка}{имеющиеся формулы}
            \scnrelfrom{следствие}{целевое высказывание}
            \scnrelfrom{основания}{основания вывода}
        \end{scnstruct}}
\end{scnindent}
\begin{scnindent}
    \scnnote{Задача пролог-программы заключается в том, чтобы доказать, является ли заданное целевое высказывание следствием из имеющихся формул и, если является, то каким образом был получен такой вывод.}
\end{scnindent}
\scnnote{Когда пользователь задает вопрос системе Пролог, система ищет соответствующие предикаты в базе знаний и, если они найдены, сравнивает их с заданными условиями.}
\scnrelfrom{проблема}{проблема системы Пролог}
\begin{scnindent}
    \scnnote{Система Пролог хорошо справляется с нетрудными задачами, однако ограничена лишь одним принципом логического вывода и не позволяет учитывать сложноструктурированные знания в различных видах логик.}
\end{scnindent}

\scnheader{абстрактная машина логического вывода}
\scnrelfrom{задается}{логический язык на основе SC-кода}
\begin{scnrelfromset}{решаемые проблемы}
    \scnitem{проблема языков логических моделей решения задач}
    \scnitem{проблема системы Пролог}
\end{scnrelfromset}

\scnheader{Технология OSTIS}
\scnrelfrom{позволяет}{интеграция любого принципа логического вывода}
\begin{scnindent}
    \scnrelfrom{цель}{решение задач в интеллектуальных системах на основе общей формальной логике}
    \scnnote{Для того, чтобы использовать какую-либо новую или существующую модель, необходимо привести ее к предлагаемому формализму, что позволит интегрировать и синхронизировать ее с уже имеющимися в соответствующей \textit{библиотеке многократно используемых компонентов ostis-систем}. Формализм \textit{SC-кода} позволяет описывать широкий спектр понятий и отношений между ними, что делает его подходящим вариантом для реализации логического вывода в интеллектуальных компьютерных системах нового поколения. Кроме того, целесообразно воспользоваться принципом наследования, лежащим в основе иерархической структуризации баз знаний ostis-систем.}
    \begin{scnindent}
        \scnrelto{объяснение}{иерархия логических предметных областей}
    \end{scnindent}
\end{scnindent}



\scnheader{иерархия логических предметных областей}
\begin{scnstruct}
    \scnheader{Предметная область логических формул, высказываний и формальных теорий}
    \begin{scnrelfromlist}{дочерняя предметная область}
        \scnitem{Предметная область логических языков}
        \scnitem{Предметная область логического вывода}
    \end{scnrelfromlist}
    
    \scnheader{Предметная область логических языков}
    \scnrelfrom{дочерняя предметная область}{Предметная область языка логики высказываний}
    \begin{scnindent}
        \scnrelfrom{дочерняя предметная область}{Предметная область языка логики предикатов}
    \end{scnindent}
    
    \scnheader{Предметная область логических моделей решения задач}
    \begin{scnreltolist}{дочерняя предметная область}
        \scnitem{Предметная область логических языков}
        \scnitem{Предметная область логического вывода}
    \end{scnreltolist}
\end{scnstruct}
\begin{scnrelfromvector}{примечание}
    \scnfileitem{Наследование предметных областей позволяет использовать описанные логики и их компоненты при описании любых логик.}
    \scnfileitem{Базовые понятия позволяют разработчикам интеллектуальной системы добавлять новые логики.}
    \scnfileitem{Для реализации конкретной логической модели решения задач необходимо создать предметную область, которая будет дочерней по отношению к \textit{Предметной области логических моделей решения задач} и предметной области некоторого \textit{логического языка}, например, языка логики высказываний, языка логики предикатов, языка нечеткой логики и других.}
\end{scnrelfromvector}

\scnheader{Предметная область логических формул, высказываний и формальных теорий}
\scnrelfrom{задает}{денотационная семантика логических формул, высказываний и формальных теорий}
\scnrelfrom{содержит}{формальная спецификация понятий}
\begin{scnindent}
    \scnrelto{необходимое условие формирования}{логические формулы и высказывания}
\end{scnindent}

\scnheader{Предметная область логических моделей решения задач}
\scnrelfrom{описанные понятия}{понятия Предметной области логических моделей решения задач}
\begin{scnindent}
    \scnrelfrom{средство интерпретации}{логические формулы и высказывания}
\end{scnindent}
\scnsubset{модель абстрактных агентов}
\scnsubset{реализация абстрактных агентов}
\begin{scnhaselementrolelist}{ключевое понятие}
    \scnitem{логический вывод}
    \scnitem{правило вывода}
    \scnitem{равносильное преобразование}
    \scnitem{аксиомная схема}
\end{scnhaselementrolelist}

\scnheader{Язык SCL}
\scnrelto{подъязык}{SC-код}
\scnrelfrom{использование}{запись логических утверждений}
\scnrelfrom{библиографический источник}{\scncite{Golenkov1996_2}}
\scnrelfrom{предметная область с описанием}{Предметная область и онтология знаний и баз знаний ostis-систем}
\scnrelfrom{высказывания языка}{высказывания Языка SCL}
\begin{scnindent}
    \scnrelto{использует}{логический вывод}
\end{scnindent}

\scnheader{вывод в формальной системе}
\scndefinition{Любая последовательность формул такая, что любая формула либо аксиома этой формальной системы, либо непосредственное следствие каких-либо предыдущих формул по одному из правил вывода}
\scnnote{Доказательство вывода формулы равносильно доказательству противоречивости вывода отрицания этой формулы. При использовании правила резолюции это особенно удобно использовать.}

\scnheader{теорема}
\scndefinition{формула, которая выводится из аксиом}

\scnheader{правильность умозаключений}
\scnrelfrom{способ ввода}{формальный ввод}
\scnrelfrom{способ проверки}{формальная проверка}
\begin{scnindent}
    \scnrelfrom{завит от}{структура умозаключений}
    \scnrelfrom{не зависит от}{истинность посылок умозаключений}
    \begin{scnindent}
        \scnrelto{задает}{состояние базы знаний}
    \end{scnindent}
\end{scnindent}
\scnrelfrom{свойство}{свойство формальной правильности умозаключений}
\begin{scnindent}
    \scnnote{Если нам удалось доказать, пользуясь методами формальной логики, правильность рассуждения, и нам известно из опыта, что все используемые посылки истинны, то мы можем быть уверены в истинности заключения}
    \scnrelfrom{библиографический источник}{\scncite{Averin2004}}
\end{scnindent}

\scnheader{классический дедуктивный вывод}
\scnnote{Некоторые операции, необходимые в одной предметной области будут избыточными в другой. Например, в системе, решающей задачи по геометрии, химии и другим естественным наукам обоснованным будет использование дедуктивных методов вывода, поскольку решение задач в таких предметных областях основывается только на достоверных правилах. В системах же медицинской диагностики, к примеру, постоянно возникает ситуация, когда диагноз может быть поставлен только с некоторой долей уверенности и абсолютно достоверным ответ на поставленный вопрос быть не может. В связи с этим возникает необходимость использования различных \textit{решателей задач} в различных системах, при этом их состав и возможности в конкретной системе определяется не только непосредственно разработчиком, а требует консультаций с экспертами в данной предметной области. Тем не менее основой для всех видов логик является классическая логика и наиболее общие ее методы распространяются на другие логики с некоторыми модификациями, уточнениями и ограничениями.}
\scnrelfrom{библиографический источник}{\scncite{Golenkov2004}}

\scnheader{логический метод решения задач}
\scnhaselement{классический дедуктивный вывод}
\begin{scnindent}
    \scnsubset{прямой логический вывод}
    \scnsubset{обратный логический вывод}
    \scnsubset{силлогизм}
    \scntext{причина популярности}{всегда дает достоверный ответ}
    \scntext{проблема}{невозможность использования, когда отсутствуют достоверные знания}
    \scnrelfrom{библиографический источник}{\scncite{Averin2004}}
    \scnrelfrom{библиографический источник}{\scncite{Sethy2021}}
\end{scnindent}
\scnhaselement{индуктивный вывод}
\begin{scnindent}
    \scntext{причина удобства}{предоставляет возможность в процессе решения использования предположений}
    \begin{scnreltolist}{используемый метод}
        \scnitem{слабоформализованная предметная область}
        \scnitem{трудноформализуемая предметная область}
    \end{scnreltolist}
    \scnrelfrom{библиографический источник}{\scncite{Norton2019}}
    \scnrelfrom{библиографический источник}{\scncite{Yuxuan2022}}
\end{scnindent}
\scnhaselement{абдуктивный вывод}
\begin{scnindent}
    \scndefinition{В искусственном интеллекте, вывод наилучшего абдуктивного объяснения события, ставшего неожиданным для системы}
    \scntext{критерий наилучшего объяснения}{объяснение, которое удовлетворяет специальным критериям, определяемым в зависимости от решаемой задачи и используемой формализации}
    \begin{scnreltolist}{используемый метод}
        \scnitem{слабоформализованная предметная область}
        \scnitem{трудноформализуемая предметная область}
    \end{scnreltolist}
    \scnrelfrom{библиографический источник}{\scncite{Safawi2015}}
    \scnrelfrom{библиографический источник}{\scncite{Gungov2018}}
\end{scnindent}
\scnhaselement{нечеткая логика}
\begin{scnindent}
    \scntext{причина удобства}{предоставляет возможность в процессе решения использования предположений}
    \scnrelto{используемый метод}{трудноформализуемая предметная область}
    \scnnote{Импликативные высказывания могут рассматриваться как "если истинна посылка"{}, то с некоторой вероятностью (часто или редко) истинно заключение, в отличие от классической логики, где зачастую используются статические предметные области и выражение "часто или редко"{} не применимо (корректно использовать только наречие "всегда"{}).}
    \scnrelfrom{библиографический источник}{\scncite{Geramian2017}}
    \scnrelfrom{библиографический источник}{\scncite{Son2017}}
    \scnrelfrom{библиографический источник}{\scncite{Uehara2017}}
\end{scnindent}
\scnhaselement{логика умолчаний}
\begin{scnindent}
    \scntext{способ оптимизации процесса рассуждения}{процесс достоверного вывода дополняется вероятностными предположениями в тех случаях, когда вероятность ошибки крайне мала}
    \scnrelfrom{библиографический источник}{\scncite{Lupea2002}}
    \scnrelfrom{библиографический источник}{\scncite{Weydert2022}}
\end{scnindent}
\scnhaselement{темпоральная логика}
\begin{scnindent}
    \scnrelto{используемый метод}{нестатичная предметная область}
    \begin{scnindent}
        \scntext{критерий нестатичности}{истинность утверждений меняется со временем}
        \scnrelfrom{возможный язык описания}{Язык SCL}
    \end{scnindent}
    \scnrelfrom{библиографический источник}{\scncite{Chen2021}}
    \scnrelfrom{библиографический источник}{\scncite{Rybakov2020}}
\end{scnindent}

\scnheader{база знаний интеллектуальной системы}
\scnsubset{модель фактографических знаний о предметной области}
\scnsubset{модель знаний, включающая в себя логические формулы о предметной области}

\scnheader{Абстрактная scl-машина}
\scniselement{машина логического вывода}
\scniselement{абстрактная sc-машина}
\scnrelfrom{библиографический источник}{\scncite{Golenkov1996_2}}
\scnrelfrom{внутренний язык}{Язык SCL}
\scnrelfrom{множество операций}{операции Абстрактной scl-машины}
\begin{scnindent}
    \scnrelto{соответствие}{правило логического вывода}
\end{scnindent}
\scnnote{Семейство специализированных абстрактных графодинамических машин обработки знаний является формальным уточнением операционной семантики указанных выше специализированных графовых языков представления знаний, каждому из которых соответствует одна или несколько абстрактных машин. Эти абстрактные машины соответствуют различным моделям решения задач, различным логикам, различным моделям правдоподобных рассуждений. }
\scnnote{Агент из семейства агентов логического вывода может представлять собой какое-либо правило вывода, которое можно применять для решения логической задачи. Кроме того, необходимы агенты для выполнения равносильных преобразований логической формулы (например, записать формулу эквиваленции как конъюнкцию двух дизъюнкций) и другие агенты, помогающие применять правила вывода на множестве формул языка логики.}
\begin{scnindent}
    \scnrelfrom{библиографический источник}{\scncite{Orlov2022b}}
\end{scnindent}

\scnheader{Абстрактная scl-машина}
\begin{scnrelfromset}{декомпозиция абстрактного sc-агента}
    \scnitem{Абстрактный sc-агент применения правила вывода}
    \begin{scnindent}
        \scnrelfrom{использует}{Абстрактный sc-агент эквивалентных преобразований логической формулы}
        \scnrelfrom{задача}{применение заданного правила вывода с заданными логическими формулами}
        \scnrelfrom{условие инициирования}{появление в sc-памяти инициированного действия, принадлежащего классу \textit{действие применение правила вывода}}
        \begin{scnrelfromvector}{последовательность действий}
            \scnitem{проверка условия инициирования}
            \scnitem{применение правил вывода}
            \begin{scnindent}
                \scnnote{проверка, существуют ли в sc-памяти структуры, соответствующие условию применения данного правила и генерация sc-конструкций в соответствии с применяемым правилом}
            \end{scnindent}
        \end{scnrelfromvector}
        \scnrelfrom{автоматически выполняемая процедура во время работы}{унификация}
        \begin{scnindent}
            \scnnote{переменные соответствуют константам, константы соответствуют самим себе}
        \end{scnindent}
        \begin{scnrelfromlist}{пример используемого правила}
            \scnheader{SCg-текст. Формализация правила вывода Modus ponens}
            \scneqimage[30em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/Modus_ponens.png}
            \scnnote{Можно привести еще целый ряд высказываний, которые описывают общие свойства всевозможных формальных теорий, каждая из которых описывает ту или иную предметную область. Свойства всевозможных формальных теорий описываются в рамках специальной метатеории для которой совокупность всевозможных формальных теорий является описываемой предметной областью.}
        \end{scnrelfromlist}
    \end{scnindent}
    \scnitem{Абстрактный sc-агент эквивалентных преобразований логической формулы}
    \begin{scnindent}
        \scnrelfrom{задача}{применение правил, которые приводят логическую формулу в определенный вид}
        \scnrelfrom{условие инициирования}{появление в sc-памяти инициированного действия, принадлежащего классу \textit{действие эквивалентное преобразование логической формулы}}
        \begin{scnrelfromvector}{последовательность действий}
            \scnitem{проверка условия инициирования}
            \scnitem{преобразование формулы из одной формы в другую}
            \begin{scnindent}
                \scnnote{При преобразовании никакие новые знания в sc-памяти с точки зрения исследуемой предметной области не генерируются.}
            \end{scnindent}
        \end{scnrelfromvector}
        \scnrelfrom{ответ}{множество формул, эквивалентных по смыслу, но различных по форме представления}
        \begin{scnindent}
            \begin{scnrelfromlist}{пример}
                \scnitem{конъюнктивная нормальная форма}
                \scnitem{дизъюнктивная нормальная форма}
            \end{scnrelfromlist}
        \end{scnindent}
        \scntext{решаемая проблема}{Логические формулы не всегда находятся в той форме, которая доступна для применения того или иного правила вывода, однако может быть приведена к нужной форме}
    \end{scnindent}
    \scnitem{Абстрактный sc-агент прямого логического вывода}
    \begin{scnindent}
        \scnrelfrom{использует}{Абстрактный sc-агент применения правила вывода}
        \scnrelfrom{задача}{генерация новых знаний на основе некоторых логических утверждений}
        \scnrelfrom{условие инициирования}{появление в sc-памяти инициированного действия, принадлежащего классу \textit{действие прямого логического вывода}}
        \begin{scnrelfromvector}{последовательность действий}
            \scnitem{проверка условия инициирования}
            \scnitem{процесс прямого логического вывода}
            \begin{scnindent}
                \begin{scnrelfromset}{декомпозиция}
                    \scnitem{применение правил вывода}
                    \begin{scnindent}
                        \scnrelfrom{основа поиска правил}{посылки формул}
                    \end{scnindent}
                    \scnitem{генерация новых знаний в sc-памяти}
                    \scnitem{проверка некоторого условия}
                    \begin{scnindent}
                        \scnrelfrom{пример}{появление в sc-памяти sc-элементов из целевой sc-структуры}
                    \end{scnindent}
                \end{scnrelfromset}
                \scnrelfrom{библиографический источник}{\scncite{Gavrilova2001}}
            \end{scnindent}
        \end{scnrelfromvector}
        \scnrelfrom{ответ}{\scnnonamednode}
        \begin{scnindent}
            \begin{scnreltoset}{объединение}
                \scnitem{целевая структура}
                \scnitem{множество формул, которые используются в ходе вывода агентом применения правил вывода}
                \scnitem{множество правил вывода}
                \scnitem{входная структура}
                \scnitem{выходная структура}
            \end{scnreltoset}
        \end{scnindent}
        \scnrelfrom{результат работы}{дерево решения}
        \begin{scnindent}
            \scnnote{Это дерево состоит из последовательности узлов, представляющих собой примененные правила, которые привели к появлению в sc-памяти требуемых знаний. Такое дерево может быть пустым в случае, если требуемую структуру не удалось сгенерировать в ходе логического вывода.}
        \end{scnindent}
        \begin{scnrelfromlist}{пример спецификации}
            \scnheader{SCg-текст. Спецификация агента прямого логического вывода}
            \scneqimage[40em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/direct_inference_agent.png}
        \end{scnrelfromlist}
    \end{scnindent}
    \scnitem{Абстрактный sc-агент обратного логического вывода}
    \begin{scnindent}
        \scnrelfrom{использует}{Абстрактный sc-агент применения правила вывода}
        \scnrelfrom{задача}{проверка гипотез}
            \begin{scnindent}
                \scnnote{Некоторые гипотезы могут быть опровергнуты, однако извлекая причины того, почему гипотеза опровергнута, можно изменить посылку гипотезы так, чтобы создать новую гипотезу, которая впоследствии может стать полезной теоремой.}
            \end{scnindent}
        \scnrelfrom{условие инициирования}{появление в sc-памяти инициированного действия, принадлежащего классу \textit{действие обратного логического вывода}}
        \begin{scnrelfromvector}{последовательность действий}
            \scnitem{проверка условия инициирования}
            \scnitem{процесс обратного логического вывода}
            \begin{scnindent}
                \scnrelfrom{основа поиска правил}{следствия формул формул}
                \scnrelfrom{библиографический источник}{\scncite{Gavrilova2001}}
            \end{scnindent}
        \end{scnrelfromvector}
        \scnrelfrom{ответ}{дерево решения}
            \begin{scnindent}
                \scntext{решаемая проблема}{Дерево решения показывает, с использованием каких правил можно доказать или опровергнуть выдвинутую гипотезу.}
            \end{scnindent}
    \end{scnindent}
\end{scnrelfromset}
\scnhaselement{Реализации интерпретатора логических моделей решения задач}
\begin{scnindent}
    \scnidtf{Реализация scl-машины}
    \scntext{адрес компонента}{https://github.com/ostis-ai/scl-machine}
\end{scnindent}

\scnheader{Абстрактный sc-агент эквивалентных преобразований логической формулы}
\begin{scnrelfromset}{декомпозиция абстрактного sc-агента}
    \scnitem{Абстрактный sc-агент преобразования формулы в конъюнктивную нормальную форму}
    \scnitem{Абстрактный sc-агент преобразования формулы в дизъюнктивную нормальную форму}
    \scnitem{Абстрактный sc-агент применения законов Де Моргана}
    \scnitem{Абстрактный sc-агент эквивалентных преобразований логической формулы по определению}
    \scnitem{Абстрактный sc-агент применения свойств отрицания логических формул}
    \scnitem{Абстрактный sc-агент применения закона идемпотентности логических формул}
    \scnitem{Абстрактный sc-агент применения закона коммутативности логических формул}
    \scnitem{Абстрактный sc-агент применения закона ассоциативности логических формул}
    \scnitem{Абстрактный sc-агент применения закона поглощения логических формул}
    \scnitem{Абстрактный sc-агент применения закона противоречия логических формул}
    \scnitem{Абстрактный sc-агент применения закона двойного отрицания логических формул}
    \scnitem{Абстрактный sc-агент применения закона расщепления логических формул}
\end{scnrelfromset}

\scnheader{правило резолюции}
\begin{scnrelfromvector}{использует}
    \scnitem{формула в конъюнктивной нормальной форме}
    \begin{scnindent}
        \scnnote{Любая формула семантически эквивалентна некоторой формуле в конъюнктивной нормальной форме, в связи с этим иногда удобно применять правило резолюции.}
        \begin{scnrelfromlist}{пример}
            \scnheader{SCg-текст. Формализация конъюнктивной нормальной формы для импликации}
            \scneqimage[30em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/conjunction_implication_rule.png}
        \end{scnrelfromlist}
    \end{scnindent}
    \scnitem{формула полученная в результате применения закона Де Моргана}
    \begin{scnindent}
        \scnnote{Используя законы Де Моргана можно получить формулы, пригодные для использования правила резолюции.}
    \end{scnindent}
\end{scnrelfromvector}
\scnrelto{использует}{доказательство формул Языка логики высказываний}
\scnnote{Ничего принципиально нового правило резолюции не привносит, поскольку формула $A \Rightarrow B$  равносильно $\neg A \lor B$ и из выводимости A и $A \rightarrow B$ следует выводимость B.}
\scntext{пример}{Если в любых двух дизъюнктах $C_1$ и $C_2$ имеется пара формул $A$ и $\neg A$, то можно сформировать новый дизъюнкт из оставшихся частей изначальных дизъюнктов.}
\begin{scnrelfromlist}{пример}
    \scnheader{SCg-текст. Формализация правила резолюции}
    \scneqimage[30em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/resolution.png}
\end{scnrelfromlist}
\scnrelfrom{пример использования}{задача с футбольными командами}
\begin{scnindent}
    \scnrelfrom{условие}{условие задачи с футбольными командами}
    \begin{scnindent}
        \scnexplanation{Если команда A выигрывает в футбол, то город A' торжествует, а если выигрывает команда B, то торжествовать будет город B'. Выиграть может или только город A', или только город B'. Однако, если выигрывает команда A, то город B' не торжествует, а если выигрывает команда B, то не торжествует город A'. Следовательно, город B' торжествует тогда и только тогда, когда не будет торжествовать город A'.}
    \end{scnindent}
    \scnrelfrom{цель}{цель задачи с футбольными командами}
    \begin{scnindent}
        \scnexplanation{Удостовериться, что город B' торжествует тогда и только тогда, когда не будет торжествовать город A'.}
    \end{scnindent}
    \begin{scnrelfromlist}{формализация формул, соответствующих задаче}
        \scnheader{SCg-текст. Формализация правил для применения правила резолюции}
        \scneqimage[30em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/resolution_formulas_example.png}
        \begin{scnindent}
            \scnnote{Каждая неатомарная формула на рисунке принадлежит некоторой формальной теории, то есть считается истинной.}
            \scnnote{Структура A представляет собой атомарную логическую формулу, которая обозначает победу команды A, структура A' представляет формулу, обозначающую торжество города A'. Соответственно, то же самое для структур B и B'.}
        \end{scnindent}
    \end{scnrelfromlist}
    \begin{scnrelfromvector}{шаги решения}
        \scnitem{выражение логических формул в булевом базисе}
        \begin{scnrelfromset}{декомпозиция}
            \scnitem{приведение импликации в конъюнктивную нормальную форму}
            \begin{scnindent}
                \scnrelfrom{используемая формула}{конъюнктивная нормальная форма для импликации}
            \end{scnindent}
            \scnitem{приведение эквиваленции в конъюнктивную нормальную форму}
            \begin{scnindent}
                \scnrelfrom{используемая формула}{определение эквиваленции}
            \end{scnindent}
        \end{scnrelfromset}
        \scnitem{применение отрицания к целевой формуле}
        \begin{scnindent}
            \begin{scnrelfromlist}{состояние после шагов решения}
                \scnheader{SCg-текст. Формализация правил для применения правила резолюции после преобразования в конъюнктивную нормальную форму}
                \scneqimage[30em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/resolution_prepared_formulas_example.png}
            \end{scnrelfromlist}
        \end{scnindent}
        \scnitem{применение правила резолюции для преобразованных формул}
        \begin{scnindent}
            \scnrelfrom{результат}{пустой дизъюнкт}
            \scnnote{Пустой дизъюнкт говорит о противоречивости множества формул и доказывает формулу эквиваленции о том, что город B' торжествует тогда и только тогда, когда не будет торжествовать город A'.}
        \end{scnindent}
    \end{scnrelfromvector}
    \begin{scnrelfromlist}{примененные правила резолюции}
        \scnheader{SCg-текст. Применение принципа резолюции}
        \scneqimage[45em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/resolution_inference.png}
    \end{scnrelfromlist}
\end{scnindent}


\bigskip
\end{scnsubstruct}
\scnendsegmentcomment{Предметная область и онтология операционной семантики логических sc-языков}
    
\end{SCn}
